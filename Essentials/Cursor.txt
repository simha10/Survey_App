üìå Cursor Prompt ‚Äî Implement SQLite for Image Storage + Selective AsyncStorage Usage

Goal: Implement a robust offline-first storage strategy using SQLite for image metadata and AsyncStorage for lightweight app data, to improve performance, scalability, and field usability.
Important: Strictly follow the existing project architecture and do not break or refactor unrelated modules. All changes should be additive and scoped, not destructive.

üß≠ Context & Requirements

The current mobile app uses AsyncStorage heavily for caching user data, assignments, survey form entries, and offline submissions.

However, AsyncStorage has a size limit of ~2 MB, making it unsuitable for storing multiple survey images.

The new feature involves capturing 4 property photos per survey. Each photo is ~2 MB in size, and must be stored offline first (before syncing to the server / Cloudinary).

Storing these photos directly in AsyncStorage is not feasible, so we will introduce SQLite as a lightweight, local metadata database, while keeping AsyncStorage for other app data.

The app is offline-first, so data must be fully usable without internet.

üß± SQLite Usage Plan

Introduce a dedicated SQLite table (e.g., SurveyImages) using expo-sqlite or react-native-sqlite-storage.

Store only metadata in SQLite:

id (autoincrement / uuid)

surveyId

photoUri (local file system path using expo-file-system)

label (e.g., "Khasra No.", "Front", "Left", "Right")

timestamp

Do not store actual image bytes or base64 in the DB to avoid bloat.

Add indexes on surveyId and timestamp for fast lookups.

üìÇ File Storage Plan

Use expo-file-system to save captured photos locally as compressed files.

Store only the file URI in SQLite.

Clean up files + DB entries after successful sync to the server/Cloudinary.

üì¶ AsyncStorage Usage Plan

Use AsyncStorage selectively for:

Caching login credentials (or use SecureStore for secure caching).

Caching master data (ULB, Zone, Ward, Mohallas) after login.

Storing unsynced survey form data (excluding images).

Tracking survey submission states (saved, submitted, synced).

Lightweight logs like synced survey count, dates, etc.

üëâ Do not store images or large objects in AsyncStorage.

üß† Implementation Steps

Create a SQLite helper module (e.g., services/sqlite.ts) to handle:

Database initialization

Table creation

Insert, fetch, and delete operations for SurveyImages

Indexed queries by surveyId

Modify image capture workflow to:

Save the image to expo-file-system

Insert a metadata row into SQLite (instead of AsyncStorage)

Modify survey submission workflow to:

When syncing, fetch metadata + files from SQLite

Upload images to Cloudinary

Update server records

On success, delete local file and SQLite row

Keep AsyncStorage for survey data, assignments, and configs, untouched except removing image references.

Add basic cleanup logic on logout or manual purge to clear SQLite image entries + file storage if needed.

‚ö†Ô∏è Critical Instructions for Cursor

Do NOT refactor unrelated features or break existing workflows.

Make minimal, targeted changes to integrate SQLite cleanly.

Keep image handling code modular (e.g., separate service files).

Do not auto-run commands ‚Äî only provide clear terminal commands for me to execute manually.

Use async, non-blocking DB operations to keep UI smooth.

Follow Expo SDK 54 compatibility for SQLite and FileSystem usage.

üß™ Post-Implementation Goals

The app should handle dozens of surveys offline with 4 photos each without performance degradation.

SQLite should store image metadata efficiently, while AsyncStorage handles structured survey data and user/session caching.

Survey sync should correctly pick up both AsyncStorage survey data and SQLite image metadata, push them to the backend, and clean up after success.

üí° Hint for Cursor: Think of AsyncStorage as ‚Äúsurvey data cache‚Äù and SQLite + FileSystem as ‚Äúmedia cache‚Äù. Keep them cleanly separated to maintain speed and offline capability.

‚úÖ End of Prompt.